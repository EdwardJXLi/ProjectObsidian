import enum
import struct

# from obsidian.network import *
# from obsidian.constants import *
from obsidian.log import Logger


# Enums
class PacketDirections(enum.Enum):
    REQUEST = 0
    RESPONSE = 1


# Packet Skeleton
class Packet:
    ID: int = None           # Packet Id
    FORMAT: str = None       # Packet Structure Format
    SIZE: int = None         # Autogenerated Size Value
    CIRTICAL: bool = None    # Packet Criticality. Dictates What Event Should Occur When Error
    MODULE: str = None       # Packet Module Owner

    @classmethod
    def _init(cls):
        cls.SIZE = struct.calcsize(cls.FORMAT)


class RequestPacket(Packet):
    DIRECTION = PacketDirections.REQUEST  # Network Direction (Response or Response)
    PLAYERLOOP: bool = None               # Accept Packet During Player Loop

    @classmethod
    def deserialize(cls, *args, **kwargs):
        return None

    @classmethod
    def postDeserialization(cls):
        pass


# Packet Skeletons
class ResponsePacket(Packet):
    DIRECTION = PacketDirections.RESPONSE    # Network Direction (Response or Response)

    @classmethod
    def serialize(cls, *args, **kwargs):
        return None

    @classmethod
    def postSterilization(cls):
        pass


#
# Request Network Packets
#
class TestPacket(RequestPacket):
    ID = 0x61
    FORMAT = "B5s"
    CIRTICAL = True
    PLAYERLOOP = False
    MODULE = "Test"

    @classmethod
    def deserialize(cls, rawData):
        _, msg = struct.unpack(cls.FORMAT, rawData)
        print(msg)
        return None

    @classmethod
    def postDeserialization(cls):
        Logger.debug("POST-DES")


class PlayerIdentificationPacket(RequestPacket):
    ID = 0x00
    FORMAT = "BB64s64sB"
    CIRTICAL = True
    PLAYERLOOP = False
    MODULE = "Core"

    @classmethod
    def deserialize(cls, rawData):
        # <Player Identification Packet>
        # (Byte) Packet ID
        # (Byte) Protocol Version
        # (64String) Username
        # (64String) Verification Key
        # (Byte) Unused
        _, protocolVersion, username, verificationKey, _ = struct.unpack(cls.FORMAT, rawData)
        # Unpackage String
        username = unpackageString(username)
        verificationKey = unpackageString(verificationKey)
        return protocolVersion, username, verificationKey

    @classmethod
    def postDeserialization(cls):
        pass


#
# Response Network Packets
#
class TestReturnPacket(ResponsePacket):
    ID = 0x61
    FORMAT = "B5s"
    CIRTICAL = True
    MODULE = "Test"

    @classmethod
    def serialize(cls):
        msg = bytes("ahello_there!\n", "ascii")
        print(msg)
        return msg

    @classmethod
    def postSterilization(cls):
        Logger.debug("POST-SER")


class ServerIdentificationPacket(ResponsePacket):
    ID = 0x00
    FORMAT = "BB64s64sB"
    CIRTICAL = True
    MODULE = "Core"

    @classmethod
    def serialize(cls, protocolVersion, name, motd, userType):
        # <Server Identification Packet>
        # (Byte) Packet ID
        # (Byte) Protocol Version
        # (64String) Server Name
        # (64String) Server MOTD
        # (Byte) User Type
        msg = struct.pack(cls.FORMAT, cls.ID, protocolVersion, packageString(name), packageString(motd), userType)
        return msg

    @classmethod
    def postSterilization(cls):
        pass


class PingPacket(ResponsePacket):
    ID = 0x01
    FORMAT = "B"
    CIRTICAL = False
    MODULE = "Core"

    @classmethod
    def serialize(cls):
        # <Ping Packet>
        # (Byte) Packet ID
        msg = struct.pack(cls.FORMAT, cls.ID)
        return msg

    @classmethod
    def postSterilization(cls):
        pass


class LevelInitializePacket(ResponsePacket):
    ID = 0x02
    FORMAT = "B"
    CIRTICAL = True
    MODULE = "Core"

    @classmethod
    def serialize(cls):
        # <Level Initialize Packet>
        # (Byte) Packet ID
        msg = struct.pack(cls.FORMAT, cls.ID)
        return msg

    @classmethod
    def postSterilization(cls):
        pass


def unpackageString(data, encoding="ascii"):
    Logger.verbose(f"Unpacking String {data}")
    # Decode Data From Bytes To String
    # Remove Excess Zeros
    return data.decode(encoding).strip()


def packageString(data, maxSize=64, encoding="ascii"):
    Logger.verbose(f"Packing String {data}")
    # Trim Text Down To maxSize
    # Fill Blank Space With Spaces Using ljust
    # Encode String Into Bytes Using Encoding
    return bytes(data[:maxSize].ljust(maxSize), encoding)


def registerCoreModules(manager):  # manager accepts any class that supports the registerInit and registerPacket function
    # Run Register Initialization
    manager.registerInit("Test")
    manager.registerInit("Core")

    # Register Downsteam Packets
    manager.registerPacket(TestPacket)
    manager.registerPacket(PlayerIdentificationPacket)

    # Register Response Packets
    manager.registerPacket(TestReturnPacket)
    manager.registerPacket(ServerIdentificationPacket)
    manager.registerPacket(PingPacket)
    manager.registerPacket(LevelInitializePacket)
